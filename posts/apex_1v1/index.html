<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.40">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-01-05">

<title>MnK vs Controller: Impact of Player Input on Apex Legends 1v1s</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-549806ee2085284f45b00abea8c6df48.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-3aad12b124c22bd7e0f946261ca30a70.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../index.html"> 
<span class="menu-text">home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">about</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">MnK vs Controller: Impact of Player Input on Apex Legends 1v1s</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">video games</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">January 5, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="roller_and_mnk.jpg" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>In my free time, I play video games, mostly of the RPG variety: Cyberpunk 2077, God of War, Baldur’s Gate III. Though one competitive one has captured me for the past few years: Apex Legends.</p>
<p>Apex Legends is a first-person shooter battle royale (you shoot guns at other characters until your team is the only one left) with hero shooter elements much like Overwatch. The raw gameplay is some of the best I’ve ever had the chance of playing and more importantly it’s a great excuse to keep up with some of my closest friends. In recent seasons, we’ve played a lot more of the ranked game mode, achieving Masters rank (~top 0.5% of players) in the current season.</p>
<p>Over these seasons, we’ve noticed a trend in the players we’re facing - more and more of them seem to be using controller instead of mouse and keyboard (mnk), the native input for PC gaming. Why might that be?</p>
<section id="primer-on-inputs" class="level2">
<h2 class="anchored" data-anchor-id="primer-on-inputs">Primer on Inputs</h2>
<p>The main difference between the 2 inputs is how they map physical space onto in game space. Essentially, a mouse detects movement through taking a large series of low resolution images and comparing them against each other. This measurement is further magnified through software defined sensitivity to achieve the movement in game.</p>
<p>In this way, given a surface that lends itself well to image comparison and a high rate of images taken per second, one can map a movement in game from point a to b to a movement in the <strong>physical</strong> world from point x to y. Given enough training, a player could theoretically learn these mappings and precisely move their mouse to the physical location that maps onto the intended movement in game - there is a 1:1 mapping between physical and in game spaces.</p>
<p>The same is not true for controllers. Each analog stick has in it potentiometers that measure the current running through the circuit. As the analog stick is moved, the resistance of the circuit is changed and in turn the current running through the potentiometers. These changes can be used to measure the exact location of the stick within its range of motion. And therein lies the problem: <em><strong>within its range of motion</strong></em> - unlike the mouse there is a limit to the physical space that the controller can take measurements over. When the controller is fully pushed to one side, that is the maximum signal that the device can send as an input.</p>
<p>Due to this imprecise mapping, it is more difficult for the controller player to achieve accuracy in game. Therefore games often apply a layer of software called aim assist.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="aim_assist_diagram.webp" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>In the diagram above, the small red circle represents the enemy player, the larger red circle is an area of interest around the enemy player called the <code>aim bubble</code>.</p>
<p>Aim assist usually works in two ways:</p>
<ol type="1">
<li>Reticle slowing</li>
<li>Rotational aim assist</li>
</ol>
<p>As the reticle moves into the aim bubble, aim assist will lower the in game sensitvity multiplier, ‘slowing’ the players aim and increasing the chance of the reticle landing on the enemy player. This is known as reticle slowing.</p>
<p>Rotational aim assist in contrast moves the reticle in the direction of the enemy player’s movement when they enter the aim bubble as long as there is some aiming or movement input from the player. In effect ‘dragging’ the reticle towards the enemy.</p>
<p>The strength of these effects are determined on a game to game basis, with some games emphasising one over the other. Within the context of first person shooters, aim assist is often discussed as ‘unfair’, this is mainly due to 2 perceived advantages:</p>
<ol type="1">
<li>Rotational aim assist adds input that doesn’t originate from the player</li>
<li>Both aim assist effects react <em><strong>instantaneously</strong></em> to information.</li>
</ol>
<p>To expand on the second point, when an enemy player changes their movement direction from left to right, rotational aim assist will immediately start pulling the reticle to the right, this is part of why aim assist makes aiming feel ‘sticky’. This is in contrast to mouse aiming where the reaction time of the player limits the speed at which the aim can adjust. The argument is that this provides the controller player with an advantage that the human body can simply not achieve - in effect mechanic doping.</p>
</section>
<section id="the-hypothesis" class="level2">
<h2 class="anchored" data-anchor-id="the-hypothesis">The Hypothesis</h2>
<p>Due to the over-tuned strength of aim assist, controller players have an advantage when compared to mouse and keyboard players. This presents itself in two ways:</p>
<ol type="1">
<li>For an individual encounter (defined to be a 1 versus 1 fight) the average controller player has a higher chance of winning compared to the average mnk player</li>
<li>The learning curve (how quickly one can improve at said encounters) is much steeper for controller players than it is for mnk players</li>
</ol>
<p>In other words, the controller player not only gets to a better place, they get there <strong><em>faster</em></strong>.</p>
</section>
<section id="dataset" class="level2">
<h2 class="anchored" data-anchor-id="dataset">Dataset</h2>
<p>Due to there being no public API for Apex Legends, I’ve had to look for alternative data sources for this analysis. Fortunately, there is a third party service <code>r5r</code> that hosts 1 versus 1 fights in servers located around the globe. The data for these matches is publically hosted at <a href="https://r5r.dev/">r5r.dev</a> and this tends to be where data concerning Apex Legends comes from.</p>
</section>
<section id="previous-research" class="level2">
<h2 class="anchored" data-anchor-id="previous-research">Previous Research</h2>
<p>Shoutout to some of the stats-inclined folks over at <a href="https://www.reddit.com/r/apexlegends">r/apexlegends</a> and <a href="https://www.reddit.com/r/CompetitiveApex/">r/CompetitiveApex</a> subreddits who have done some investigation into the topic.</p>
<p>Specfically reddit user <a href="https://www.reddit.com/user/lifeisbadclothing/">lifeisbadclothing</a> has conducted research collating the performance of the top 10,000 players in r5r. Seen here below:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="previous_r5r_research.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>Big headline takeaways:</p>
<ul>
<li>controller player average accuracy is 30.5% higher than mnk players</li>
<li>controller players’ average KD (kill-death ratio, since encounters are 1v1, this can be seen as ratio of wins to losses) is 31.5% higher than mnk players</li>
<li>the accuracy of the top quartile of controller players is higher than the 99.93 percentile of mnk players</li>
</ul>
<p>These numbers provide strong evidence for hypothesis 1 - the average controller player does indeed seem to have a higher chance of winning an encounter when compared to the mnk player.</p>
<p>The analysis I want to bring will consist of two parts: 1. confirm the findings found by <code>lifeisbadclothing</code> 2. expand upon the analysis through creating ‘learning curves’</p>
</section>
<section id="distribution-differences" class="level2">
<h2 class="anchored" data-anchor-id="distribution-differences">Distribution Differences</h2>
<p>The data I’ve gathered here spans <code>2024-02-22</code> to <code>2024-07-16</code> and includes:</p>
<ul>
<li>79,940 matches (a match here is a series of 1v1s between players in a single server)</li>
<li>60,861 unique players</li>
<li>47,362,344 individual fights (1v1s)</li>
<li>189,496,133 fight events.</li>
</ul>
<p>In order to confirm the findings of <code>lifeisbadclothing</code>, we compare the distribution of mean player accuracies for the controller and mnk populations.</p>
<div>

</div>
<div id="fig" class="quarto-layout-panel" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="controller_vs_mnk_accuracy_mean.png" class="img-fluid"></p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: center;">
<p><img src="controller_vs_mnk_accuracy_std.png" class="img-fluid"></p>
</div>
</div>
</div>
<p>The data here has been filtered down to exclude the bottom 20% of players in terms of playing time (roughly speaking they played less than 10 minutes of r5r). The graphs are showing the mean/std accuracy distribution for the controller and mnk players.</p>
<p>Two things stand out when comparing controller vs mnk players: - the mean of mean accuracies for controller players seem to be higher - the standard deviation of mean accuracies for controller players seem to be tighter</p>
<p>Simple KS test returns p-value of 0 for the accuracy mean distribution and a p-value of <span class="math inline">\(6*10^{-196}\)</span>, so highly significant in both cases.</p>
<p>Not only are controller players more accurate on average, they are also more consistent. I find the second element to be particulary interesting.</p>
<p>In battle royales such as Apex Legends, the game boils down to winning a series of team fights. A key step in winning a team fight in Apex is generating a knock - that is defeating 1 member of the opposing team. This often opens up the opportunity for the rest of the team to collapse onto the enemies, in turn generating a numbers advantage and finishing the fight. The ease with which a team can do this is strongly influenced by the individual gun skill of the team members.</p>
<p>Accuracy is an important element of gun skill - the higher the accuracy the more damage one can output. Most concerns regarding aim assist address this point - that higher accuracy translates to greater ease in getting a knock, and therefore a higher chance in winning the fight. It is clear that lower standard deviation in aim accuracy of course leads to more consistent outcomes as well, which very much helps given the high-stakes of each encounter. There is however, a secondary benefit, having higher consistency unlocks more planning options.</p>
<p>I often think about Apex in terms of gambles - each team fight is a gamble and to win the game you have to consecutively win ~5 gambles. In my role as IGL (in game leader), my job is to stack the odds of those gambles in my team’s favour - that is to take the right fight at the right place and time in the right way. These gambles are a matter of planning around your knowns and unknowns. The more you can reduce the set of unknowns, the easier planning becomes. If I know that my teammate can be reliably output a certain amount of damage, then more options can open up for planning. In the extreme scenario, imagine a teammate that either does enough damage to get a knock or none at all, the entire plan would have to hinge around how that coin flip goes: regroup if the teammate does no damage, push if they get a knock.</p>
<p>It is incredibly difficult to build consistency in how to approach a situation if at the end of the day, a key part of the plan is just a coin flip. Compared to a situation where a teammate reliably does half the damage needed for a knock. Now we can start planning around it: we can take another angle whilst the opponent heals or we can push aggressively onto that player; more options present themselves. After all it is much easier to plan around a known than an unknown.</p>
</section>
<section id="learning-curves" class="level2">
<h2 class="anchored" data-anchor-id="learning-curves">Learning Curves</h2>
<p>Having confirmed previous findings, I turned my attention to the second point in my hypothesis - that controller players improve more quickly than mnk players.</p>
<p>The metric we’ll concentrate on measuring here is k/d ratio, that is the ratio of kills to deaths. Given that we are looking at 1v1s, this will map precisely onto whether the player won or loss the fight. We can treat 1.0 k/d as a breakeven point - for every loss you get a win, above that one is more likely to win than lose. K/D will tend to be noisy over a small amount of fights, so we look at the rolling mean of a player’s k/d over a window, I’ve chosen 20 fights here as it seems to capture the trend movement whilst helping remove some of the noise. Additionally, I’ve filtered for only players who’ve played more than 60 minutes of r5 within their lifetime, this roughly represents the top 50% of players in terms of time spent in r5.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="controller_vs_mnk_learning_curve.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>On the x-axis here is the cumulative number of fights for the player and on the y axis is the rolling mean of k/d over a 20 fight window.</p>
<p>One can see that even at the very beginning of a player’s history, controller players are on average net positive players with k/d &gt; 1, whereas the mnk player does not reach k/d of 1.0 until much later on, having to play ~350 games to reach that point.</p>
<p>It is also interesting to note that the returns to playing games on r5 as a way of improving quite quickly diminish as the slope of the learning curve quite quickly becomes shallow, though this shift in slope seems to happen a bit later for the controller player compared to the mnk player.</p>
<p>To investigate this effect a bit further I decided to split the learning curve into quartiles depending on the k/d these players had at 20 games played. I’ve also considered survivorship bias effect here and only included the players that have played at minimum 1000 games. That way we are looking at a constant population throughout time:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="controller_vs_mnk_quartile_learning_curves.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>A few takeaways:</p>
<ul>
<li>The mnk player quartile performs worse than its respective controller player quartile counterpart, this is expected behaviour. Though what’s not expected is how the top quartile of controller players stand above everyone else</li>
<li>Across both controllers and mnk players, the higher your initial k/d ratio the shallower the slope of your learning curve. This makes sense intuitively, the marginal learning is always more difficult, those that start from a lower k/d have more room to learn the ‘low hanging fruit’ as it were</li>
<li>We can also see that the learning curve for controller player quartiles is indeed steeper than its mnk player quartiles counterpart - evidence towards our hypothesis</li>
<li>Interestingly, the point at which the learning curve gradient changes happens at a similar point across all groups.</li>
</ul>
</section>
<section id="a-better-measure-of-skill" class="level2">
<h2 class="anchored" data-anchor-id="a-better-measure-of-skill">A better measure of skill?</h2>
<p>A big thing that the analysis so far has not addressed is the matter of matchmaking. What we really want here at the end of the day is a measuring of skill, k/d ratio offers us a view, but it doesn’t take into account how players match up against each other. How do we compare a player that holds a 1.0 k/d but plays against the highest level of competition vs a player that holds a 2.0 k/d but plays against only the bottom 10% of players? We need some type of relative skill measure - ELO seemed like a good port of call.</p>
<p>ELO has been traditionally used in zero-sum games as a measure of relative skill within that domain, it assigns each player in the system a rating that when matched together with an opponent’s ratings gives the expected odds of the player winning said game. Each game played serves as a chance to update both player’s scores, with enough games played, the rating should reflect a player’s relative skill in the system. The two main ELO equations are as follows:</p>
<p><span class="math display">\[
E_a = \frac{1}{1+10^{\frac{R_b - R_a}{c}}}
\]</span></p>
<p><span class="math display">\[
R'_a = R_a + K * (S_a - E_a)
\]</span></p>
<p>The first equation describes the expected odds of winning the game from player a’s perspective (<span class="math inline">\(E_a\)</span>), which is proportional to difference in ratings between player a and b (<span class="math inline">\(R_b - R_a\)</span>) and a scaling factor <span class="math inline">\(c\)</span>. The larger the scaling factor, the larger the difference in score is needed in order for the same increase in odds of winning for player a.</p>
<p>The second equation describes how the rating for player a is updated, which is simply the difference between actual and expected outcome (<span class="math inline">\(S_a - E_a\)</span>) from player a’s perspective multipled by a scaling factor K. The larger the scaling factor the faster the rating can move, but it can also make the ratings very noisy.</p>
<p>In my first iteration of the ELO setup I closely mimicked how ELO is setup for chess. I assigned players a starting ELO of 1500, a minimum ELO of 100 (player’s can’t drop beneath this), had K set at 32, and had scaling factor c set to 400.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="controller_vs_mnk_elo_learning_curve.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>The ELO rating learning curve actually allows us some more interesting insights. There is a dip in ELO for mnk players as soon as they start playing r5 - this is an indication tgat controller and mnk players <em>don’t</em> have the same relative skill to begin with. Assigning those two populations the same ELO may not be the correct thing to do.</p>
<p>Another encouraging sign - compared to K/D learning curve, where the gradient quite quickly becomes shallow, the ELO learning curves paint a different picture; though diminishing returns to games played on r5 still exist, the graph suggests that there’s not as much of a plateau.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="controller_vs_mnk_elo_distribution.png" class="img-fluid quarto-figure quarto-figure-center figure-img"></p>
</figure>
</div>
<p>If we look at the distribution of latest ELO score for all players we can see that the ELO of mnk players is on average lower than that of the controller players, with a larger spread. Almost all top ELO players are controller players as well. It is also important to not discount the work that controller players have put in - they too have obstacles to overcome. Aiming at longer ranges is more difficult with controller and movement techniques are more limited. Putting in the work should always be respected! It’s not their fault that the game devs haven’t balanced the two inputs well - some games in fact don’t allow mixed inputs in competitive settings, Marvel Rivals and Halo Infinite for example.</p>
</section>
<section id="should-i-play-controller-then" class="level2">
<h2 class="anchored" data-anchor-id="should-i-play-controller-then">Should I play controller then?</h2>
<p>The analysis shows that controllers offer an edge against mnk players, in terms of how it impacts accuracy and also how easy it is to pick up and improve at, but does that mean everyone should play controller? Maybe not… My analysis was done back when Apex had it’s aim assist level set to 1.4, since this analysis it has now been decreased by the development team down to 1.3, reducing its advantage in the game. Moreover, Aim is only an aspect of the game, game-sense, communication, teamwork, these are all arguably more important (granted after aim becomes at least serviceable). Instead of grinding those 1v1s, sometimes it’s much more helpful to look at footage and figure out mental errors!</p>
</section>
<section id="further-research" class="level2">
<h2 class="anchored" data-anchor-id="further-research">Further research</h2>
<p>There’s so many things to follow up on, but on my mind are:</p>
<ul>
<li>investigating the impact of lowering aim assist to 1.3, given that aim assist was 1.4 before this is a very good natural experiment</li>
<li>investigating different ELO setups and see how this impacts our analysis, particular interested in incoporating how close the fights were as a component of rating updates</li>
<li>investigating damage differentials within fights and see how these scale with input/ELO</li>
</ul>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/Alei35\.github\.io\/alei35\.github\.io\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>